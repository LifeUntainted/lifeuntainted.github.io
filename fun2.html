<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crazy Interactive 3D Animation with Three.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-family: Arial, sans-serif;
      z-index: 1;
    }
    #info h1 {
      margin: 0;
      padding: 0;
      font-size: 24px;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>Crazy Interactive 3D Animation</h1>
    <p>Move your mouse or touch to interact with the particles.</p>
  </div>
  <!-- Include Three.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <!-- Include OrbitControls for camera manipulation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/examples/js/controls/OrbitControls.js"></script>
  <!-- Include the GPUComputationRenderer for shaders -->
  <script src="https://threejs.org/examples/jsm/misc/GPUComputationRenderer.js"></script>
  <script>
    let scene, camera, renderer, controls;
    let particleSystem, uniforms;
    let clock = new THREE.Clock();
    let mouseX = 0, mouseY = 0;
    const PARTICLE_COUNT = 100000;
    const PARTICLE_SIZE = 1;

    init();
    animate();

    function init() {
      // Scene and Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
      camera.position.z = 100;

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Particles Geometry
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const velocities = new Float32Array(PARTICLE_COUNT * 3);
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;

        velocities[i * 3] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

      // Particles Material
      uniforms = {
        pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png') },
        time: { value: 1.0 },
        mouse: { value: new THREE.Vector3() }
      };
      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader(),
        fragmentShader: fragmentShader(),
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
      });

      // Particle System
      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      // Event Listeners
      document.addEventListener('mousemove', onDocumentMouseMove, false);
      document.addEventListener('touchmove', onDocumentTouchMove, false);
      window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      uniforms.mouse.value.x = mouseX * 100;
      uniforms.mouse.value.y = mouseY * 100;
    }

    function onDocumentTouchMove(event) {
      if (event.touches.length > 0) {
        mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        uniforms.mouse.value.x = mouseX * 100;
        uniforms.mouse.value.y = mouseY * 100;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      render();
    }

    function render() {
      const delta = clock.getDelta();
      uniforms.time.value += delta * 5;

      controls.update();

      particleSystem.rotation.y += 0.001;

      renderer.render(scene, camera);
    }

    function vertexShader() {
      return `
        uniform float time;
        uniform vec3 mouse;
        attribute float size;
        attribute vec3 velocity;
        varying vec3 vColor;

        void main() {
          vec3 pos = position;

          float dist = distance(mouse, pos);
          if (dist < 20.0) {
            vec3 dir = normalize(pos - mouse);
            pos += dir * (20.0 - dist) * 0.1;
          }

          pos += velocity;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = ${PARTICLE_SIZE.toFixed(1)} * (300.0 / -mvPosition.z);
          vColor = color;
        }
      `;
    }

    function fragmentShader() {
      return `
        uniform sampler2D pointTexture;
        varying vec3 vColor;

        void main() {
          vec4 color = vec4(vColor, 1.0);
          color *= texture2D(pointTexture, gl_PointCoord);
          gl_FragColor = color;
        }
      `;
    }
  </script>
</body>
</html>
