<!DOCTYPE html>
<html>
<head>
<title>Drone Battery Collector</title>
<style>
body { margin: 0; overflow: hidden; background-color: #222; }
canvas { display: block; }
</style>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Adjust map size to fit the screen better
const mapWidth = Math.min(canvas.width * 0.8, canvas.height * 0.8); 
const mapHeight = mapWidth; // Keep it square
const mapX = (canvas.width - mapWidth) / 2;
const mapY = (canvas.height - mapHeight) / 2;

const map = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
  [1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], 
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1]  
];

const tileSize = mapWidth / map[0].length;

let drone = {
  x: mapX + tileSize * 9,
  y: mapY + tileSize * 11, 
  size: tileSize * 0.6,
  speed: tileSize * 0.2, 
  direction: 'right', 
  angle: 0,
};

let batteries = []; 
let batteryCount = 30;
generateBatteries();

let score = 0;
let powerLevel = 100;
let gameOver = false;

function generateBatteries() {
  batteries = [];
  for (let i = 0; i < batteryCount; i++) { 
    let x, y;
    do {
      x = Math.floor(Math.random() * map[0].length);
      y = Math.floor(Math.random() * map.length);
    } while (map[y][x] === 1); 

    batteries.push({
      x: mapX + x * tileSize + tileSize / 2,
      y: mapY + y * tileSize + tileSize / 2,
      size: tileSize * 0.3, 
      active: true
    });
  }
}

function drawMap() {
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 2;
  for (let row = 0; row < map.length; row++) {
    for (let col = 0; col < map[row].length; col++) {
      if (map[row][col] === 1) {
        ctx.strokeRect(mapX + col * tileSize, mapY + row * tileSize, tileSize, tileSize);
      }
    }
  }
}

function drawDrone() {
  ctx.save();
  ctx.translate(drone.x, drone.y);
  ctx.rotate(drone.angle);

  // Draw drone body
  ctx.fillStyle = 'gray';
  ctx.beginPath();
  ctx.arc(0, 0, drone.size / 2, 0, Math.PI * 2);
  ctx.fill();

  // Draw drone arms
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-drone.size / 3, -drone.size / 3);
  ctx.lineTo(drone.size / 3, -drone.size / 3);
  ctx.moveTo(-drone.size / 3, drone.size / 3);
  ctx.lineTo(drone.size / 3, drone.size / 3);
  ctx.stroke();

  // Draw propellers
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(-drone.size / 3, -drone.size / 3, drone.size / 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(drone.size / 3, -drone.size / 3, drone.size / 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-drone.size / 3, drone.size / 3, drone.size / 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(drone.size / 3, drone.size / 3, drone.size / 6, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawBatteries() {
  ctx.fillStyle = 'green'; 
  batteries.forEach(battery => {
    if (battery.active) {
      ctx.beginPath();
      ctx.arc(battery.x, battery.y, battery.size, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

function updateDroneAngle() {
  switch (drone.direction) {
    case 'up':
      drone.angle = -Math.PI / 2;
      break;
    case 'down':
      drone.angle = Math.PI / 2;
      break;
    case 'left':
      drone.angle = Math.PI;
      break;
    case 'right':
      drone.angle = 0;
      break;
  }
}

function moveDrone() {
  let newX = drone.x;
  let newY = drone.y;

  switch (drone.direction) {
    case 'up':
      newY -= drone.speed;
      break;
    case 'down':
      newY += drone.speed;
      break;
    case 'left':
      newX -= drone.speed;
      break;
    case 'right':
      newX += drone.speed;
      break;
  }

  const gridX = Math.floor((newX - mapX) / tileSize);
  const gridY = Math.floor((newY - mapY) / tileSize);

  if (gridX >= 0 && gridX < map[0].length && 
      gridY >= 0 && gridY < map.length && 
      map[gridY][gridX] === 0) {
    drone.x = newX;
    drone.y = newY;
  } 
}

function checkBatteryCollisions() {
  batteries.forEach((battery, index) => {  
    if (battery.active) {
      const dx = drone.x - battery.x;
      const dy = drone.y - battery.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < drone.size / 2 + battery.size) {
        battery.active = false;
        score += 10;
        powerLevel = Math.min(powerLevel + 20, 100); 
      }
    }
  });

  // Check if all batteries are collected
  if (batteries.every(battery => !battery.active)) {
    gameOver = true;
    alert('You Win! - All batteries collected!');
    resetGame();
  }
}

function resetGame() {
  gameOver = false;
  score = 0;
  powerLevel = 100;
  drone.x = mapX + tileSize * 9;
  drone.y = mapY + tileSize * 11;
  generateBatteries(); 
}

window.addEventListener('keydown', (event) => {
  if (!gameOver) {
    switch (event.key) {
      case 'ArrowUp':
        drone.direction = 'up';
        break;
      case 'ArrowDown':
        drone.direction = 'down';
        break;
      case 'ArrowLeft':
        drone.direction = 'left';
        break;
      case 'ArrowRight':
        drone.direction = 'right';
        break;
    }
  } else {
    resetGame();
  }
});

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();
  drawDrone();
  drawBatteries();

  if (!gameOver) {
    moveDrone();
    updateDroneAngle(); 
    checkBatteryCollisions();

    powerLevel = Math.max(powerLevel - 0.05, 0); 

    if (powerLevel === 0) {
      gameOver = true;
      alert('Game Over! - You ran out of power!');
      resetGame();
    }
  }

  // Display score and power level
  ctx.fillStyle = '#fff';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, 20, 30);
  ctx.fillText(`Power: ${powerLevel}%`, 20, 60);

  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
