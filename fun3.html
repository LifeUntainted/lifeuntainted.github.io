<!DOCTYPE html>
<html>
<head>
<title>Drone Battery Collector</title>
<style>
body { margin: 0; overflow: hidden; background-color: #222; }
canvas { display: block; }
</style>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Adjust map size to fit the screen better
const mapWidth = Math.min(canvas.width * 0.8, canvas.height * 0.8); 
const mapHeight = mapWidth; // Keep it square
const mapX = (canvas.width - mapWidth) / 2;
const mapY = (canvas.height - mapHeight) / 2;

const map = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
  [1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
];

const tileSize = mapWidth / map[0].length;

const drone = {
  x: mapX + tileSize * 9,
  y: mapY + tileSize * 13,
  size: tileSize * 0.6,
  speed: 2,
  direction: 'right', 
  angle: 0,
};

const batteries = []; 
for (let i = 0; i < 30; i++) { // Reduced number of batteries
  let x, y;
  do {
    x = Math.floor(Math.random() * map[0].length);
    y = Math.floor(Math.random() * map.length);
  } while (map[y][x] === 1); // Ensure batteries are placed in valid positions

  batteries.push({
    x: mapX + x * tileSize + tileSize / 2,
    y: mapY + y * tileSize + tileSize / 2,
    size: tileSize * 0.3, // Increased battery size
    active: true
  });
}

let score = 0;
let powerLevel = 100; // Initial power level

function drawMap() {
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 2;
  for (let row = 0; row < map.length; row++) {
    for (let col = 0; col < map[row].length; col++) {
      if (map[row][col] === 1) {
        ctx.strokeRect(mapX + col * tileSize, mapY + row * tileSize, tileSize, tileSize);
      }
    }
  }
}

function drawDrone() {
  ctx.save();
  ctx.translate(drone.x, drone.y);
  ctx.rotate(drone.angle);

  // Draw drone body
  ctx.fillStyle = 'gray';
  ctx.beginPath();
  ctx.arc(0, 0, drone.size / 2, 0, Math.PI * 2);
  ctx.fill();

  // Draw drone arms
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-drone.size / 3, -drone.size / 3);
  ctx.lineTo(drone.size / 3, -drone.size / 3);
  ctx.moveTo(-drone.size / 3, drone.size / 3);
  ctx.lineTo(drone.size / 3, drone.size / 3);
  ctx.stroke();

  ctx.restore();
}

function drawBatteries() {
  ctx.fillStyle = 'green'; 
  batteries.forEach(battery => {
    if (battery.active) {
      ctx.beginPath();
      ctx.arc(battery.x, battery.y, battery.size, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

function updateDroneAngle() {
  // ... (same as before)
}

function moveDrone() {
  // ... (same as before)
}

function checkBatteryCollisions() {
  batteries.forEach((battery, index) => {  
    if (battery.active) {
      const dx = drone.x - battery.x;
      const dy = drone.y - battery.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < drone.size / 2 + battery.size) {
        battery.active = false;
        score += 10;
        powerLevel = Math.min(powerLevel + 20, 100); // Increase power level, cap at 100
      }
    }
  });
}

window.addEventListener('keydown', (event) => {
  // ... (same as before)
});

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();
  drawDrone();
  drawBatteries();

  moveDrone();
  updateDroneAngle(); 
  checkBatteryCollisions();

  // Display score and power level
  ctx.fillStyle = '#fff';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, 20, 30);
  ctx.fillText(`Power: ${powerLevel}%`, 20, 60);

  // Decrease power level over time
  powerLevel = Math.max(powerLevel - 0.05, 0); // Decrease power, cap at 0

  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
