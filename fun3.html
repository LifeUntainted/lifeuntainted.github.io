<!DOCTYPE html>
<html>
<head>
<title>Drone Battery Collector</title>
<style>
body { margin: 0; overflow: hidden; background-color: #222; }
canvas { display: block; }
</style>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const mapWidth = canvas.width * 0.8;
const mapHeight = canvas.height * 0.8;
const mapX = (canvas.width - mapWidth) / 2;
const mapY = (canvas.height - mapHeight) / 2;

const map = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
  [1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
  [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
  [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
];

const tileSize = mapWidth / map[0].length;

const drone = {
  x: mapX + tileSize * 9,
  y: mapY + tileSize * 13,
  size: tileSize * 0.6,
  speed: 2,
  direction: 'right', 
  angle: 0 
};

const batteries = []; 
for (let row = 0; row < map.length; row++) {
  for (let col = 0; col < map[row].length; col++) {
    if (map[row][col] === 0) {
      batteries.push({
        x: mapX + col * tileSize + tileSize / 2,
        y: mapY + row * tileSize + tileSize / 2,
        size: tileSize * 0.2,
        active: true
      });
    }
  }
}

let score = 0;

function drawMap() {
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 2;
  for (let row = 0; row < map.length; row++) {
    for (let col = 0; col < map[row].length; col++) {
      if (map[row][col] === 1) {
        ctx.strokeRect(mapX + col * tileSize, mapY + row * tileSize, tileSize, tileSize);
      }
    }
  }
}

function drawDrone() {
  ctx.save();
  ctx.translate(drone.x, drone.y);
  ctx.rotate(drone.angle); 

  ctx.fillStyle = 'gray';
  ctx.beginPath();
  ctx.arc(0, 0, drone.size / 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = 'red'; 
  ctx.fillRect(-drone.size / 4, -drone.size / 8, drone.size / 2, drone.size / 4);

  ctx.restore();
}


function drawBatteries() {
  ctx.fillStyle = 'green'; 
  batteries.forEach(battery => {
    if (battery.active) {
      ctx.beginPath();
      ctx.arc(battery.x, battery.y, battery.size, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

function updateDroneAngle() {
  switch (drone.direction) {
    case 'up':
      drone.angle = -Math.PI / 2;
      break;
    case 'down':
      drone.angle = Math.PI / 2;
      break;
    case 'left':
      drone.angle = Math.PI;
      break;
    case 'right':
      drone.angle = 0;
      break;
  }
}

function moveDrone() {
  let newX = drone.x;
  let newY = drone.y;

  switch (drone.direction) {
    case 'up':
      newY -= drone.speed;
      break;
    case 'down':
      newY += drone.speed;
      break;
    case 'left':
      newX -= drone.speed;
      break;
    case 'right':
      newX += drone.speed;
      break;
  }

  const gridX = Math.floor((newX - mapX) / tileSize);
  const gridY = Math.floor((newY - mapY) / tileSize);

  if (gridX >= 0 && gridX < map[0].length && 
      gridY >= 0 && gridY < map.length && 
      map[gridY][gridX] === 0) {
    drone.x = newX;
    drone.y = newY;
  } 
}

function checkBatteryCollisions() {
  batteries.forEach((battery, index) => {  
    if (battery.active) {
      const dx = drone.x - battery.x;
      const dy = drone.y - battery.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < drone.size / 2 + battery.size) {
        battery.active = false;
        score += 10;
      }
    }
  });
}

window.addEventListener('keydown', (event) => {
  switch (event.key) {
    case 'ArrowUp':
      drone.direction = 'up';
      break;
    case 'ArrowDown':
      drone.direction = 'down';
      break;
    case 'ArrowLeft':
      drone.direction = 'left';
      break;
    case 'ArrowRight':
      drone.direction = 'right';
      break;
  }
});

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();
  drawDrone();
  drawBatteries();

  moveDrone();
  updateDroneAngle(); 
  checkBatteryCollisions();

  ctx.fillStyle = '#fff';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, 20, 30);

  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
